---
title: 20180920 TIL
date: 2018-09-20 22:36:56
tags: complexity, big-O, enum
---

## 알고리즘 복잡도 complexity
[참고 - 시간 복잡도 vs 공간 복잡도](https://ledgku.tistory.com/33)
- 성능 분석을 위해 사용된다.
  - 공간 복잡도 - 메모리 의 관점에서 알고리즘의 효율 측정 및 분석
  - 시간 복잡도 - 실행 시간 의 관점에서 알고리즘의 효율 측정 및 분석

### 시간 복잡도
- `T(n)`: 사이즈가 n인 문제를 푸는 데 걸리는 시간. 연산 과정(Step), 연산자(operator) 의 수에 따라 결정된다.

```swift
// 복잡도 : T(n) = 1 + n
func sumOfN(_ N: Int) {
    var theSum = 0     // 1번 실행됨
    for i in range(1,N+1) {
        theSum += i     // N번 실행됨
    }
    return theSum
}
```
- 시간 복잡도에서 가장 큰 영향을 미치는 부분은, `T(n)`의 최고 차항 부분이다. 따라서 최고차항에 근거하여 시간의 복잡도를 나타내는 점근적 표기법이 Big-O Notation 이고, `O(f(n))` 과 같이 표기한다. (O: Order)
- Big-O Notation : 시간복잡도를 나타낼 때 가장 많이 쓰이는 표현으로, 실행 시간의 상한을 명시한다.
  - `T(n) = n^4 + n^3 + n^2 + 1 //O(n4)`

### 공간 복잡도
- 메모리를 얼마나 사용하는지 계산한다.
  - ex) 크기가 `n`인 배열을 입력했을 때, 알고리즘이 내부에서 `n*n`의 이차원 배열을 생성한다면 이 알고리즘의 공간복잡도는 `n^2` 이다.
- 시간 복잡도보다 덜 중요하게 여겨지나, 빅 데이터 처리 등의 경우 공간복잡도가 크게 뛰면 프로그램 실행이 불가능한 문제가 생길 수 있다. 그러므로 아예 간과하는 것은 좋지 않다.

### 점근적 표기법 Asymptotic Notation
- 한 문제를 해결하기 위한 알고리즘은 무수히 많으므로, 해당 알고리즘의 계산된 복잡도를 기준함수에 어떻게 근접해있는가로 나타낸다.
  - Big-O Notaiton : 주어진 알고리즘이 아무리 나빠도 기준함수와 같거나 좋다.
  - Ω Notation : 주어진 알고리즘이 아무리 좋아도 기준함수와 같거나 나쁘다.
  - Θ Notation : 주어진 알고리즘이 아무리 좋아지거나 나빠지더라도 기준 함수들의 범위 안에 있다.

***

## 열거형 enum

```swift
enum Weekday { //(UpperCamel)
    case mon //(lowerCamel)
    case tue
    case wed
    case thu
    case fri, sat, sun
}

var day = Weekday = Weekday.mon

switch day {
    case .mon, .tue, .wed, .thu:
    print("평일")
    case .fri:
    print("불금")
    case .sat, sun:
    print("주말")
}
```

### enum의 원시값 rawValue
```swift
enum Numbers: Int {
    case one = 1
    case two = 2
    case three    //자동 입력
    case four
    case five
}
var numberTwo = Numbers.two.rawValue   // numberTwo == 2
let numberFour: Numbers? = Numbers(rawValue: 4)   // 해당 원시값이 열거형에 없을 수 있으므로 옵셔널 타입이다.
```

### enum의 메서드 정의
```swift
enum UnitOfLength: Double {
    case cm = 0.01
    case m = 1
    case in = 0.0254
    case yd = 0.9144

    func convertUnit() {
        switch self {
            case .cm
            print("\UnitOfLength.cm.rawValue)m")
            case .m
            print("\UnitOfLength.m.rawValue)m")
            case .in
            print("\UnitOfLength.in.rawValue)m")
            case .yd
            print("\UnitOfLength.yd.rawValue)m")
        }
    }
}
UnitOfLength.in.convertUnit() // "0.0254m"
```

***

## 분석과 설계, 개발

### Requirement -> Feature -> Specification
- 설계까지 손으로 많이 해보자. 코딩과 별개의 과정이 아니고, 코딩 계획서나 다름없기 때문에 두 실력이 같이 필요하다.

### 추상화 단계
1. Block Diagram
2. Flow Chart - main함수의 역할. 미션 시작할 때마다 손으로 연습해보자.
3. Sequence Diagram

### Indirection 간접참조
- 변수
- 포인터 : 간접참조하는 변수를 간접참조하는 변수. 여러개의 변수를 참조할 수 있다. 움직일 수 있는 차원이 하나 늘어나는 것이므로, 많은 문제를 해결할 수 있음.
- 연속배열(Array)과 (링크드)리스트의 차이점 공부해보자

### 함수의 구조
- callee : 하위 모듈
  - 매개변수 or 인자 : 받아서 넘겨주는 것. Parameters. 값이 들어가는 위치?를 뜻한다.
- caller : 상위 모듈
  - 인수 : 넣어주는 값. Arguments
- 하위모듈이 더 많아야 하고, 더 작은 조각이어야 한다. 개별적으로 구체적이어야 한다.
- 상위모듈은 하위모듈을 잘 조합해야하고, 개별적으로 추상적이어야 한다.
