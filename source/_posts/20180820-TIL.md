---
title: 20180820 TIL
date: 2018-08-20 21:25:35
categories: [TIL]
tags: [DOM, HTML, Collection, getElementsByClassName, querySelectorAll]
---

## 객체를 나누는 좋은 기준은 무엇일까?

### 기능별로 나누었을 때의 장단점
- 장점 : 기능을 부분 개선 할 때 작업할 구역을 쉽게 좁힐 수 있다. 코드를 읽을 때 객체명을 통해 파악하기 용이.
- 단점 : 완벽히 같은 기능을 하는 요소를 사용하게 될 때에, 객체 구조를 유지하기 위해 중복 코딩을 강제당하는 경우가 발생할 수 있음.

### 유지보수가 좋은 코딩은?
- 여러가지 측면이 있겠지만, 오늘의 깨달음은 상수는 가능한 배제, 대신에 변수에 담자.
  - 한가지 수치를 변경하게 될 때 그 수치가 상수로 작성돼 있다면 각각의 수를 바꿔야 하지만, 변수라면 선언부에서 한번의 수정으로 가능. 
  - 수가 많지 않을 때라도, 상수로 쓰기보단 해당 값을 참조하는 형식으로 코드 작성하는 것이 좋은 코딩 같다. (ex. `str.length` 등등).

## 숫자야구 개선
- 위의 생각처럼, 실제로 숫자야구 자릿수를 3개에서 4개로 바꾸는 데에 총 8번의 수정이 필요했다. 다 변수로 바꿔버렸다.
- 처음 작업할 때, 3자리수여서 날코딩했던 그래픽 요소 또한 반복문으로 바꿔야 했다. 항상 큰 사이즈의 프로그래밍을 상정하고 코딩해야 한다…

### HTMLCollection 의 제어
- `getElementsByClassName`(s복수형 주의)이나 `querySelectorAll` 로 HTML요소를 가져오게 되면, 배열과 유사한 형태로 `HTMLCollection`이 만들어지게 된다. 여기에 innerHTML로 텍스트를 바꿔넣으려고 애를 썼는데, 단일 요소일 때랑 다르게 배열모양이니 각각의 배열요소를 제어하듯이 반복문을 돌려줘야 한다.
- 예를 들어, class가 front인 요소에 innerHTML을 사용하여 "TEXT"라는 텍스트를 넣고 싶을 때는 아래와 같다.
```html
<span class = 'front'></span>
<span class = 'front'></span>
<span class = 'front'></span>
<span class = 'front'></span> 
<!-- 가 있을 때 -->

<script>
var x = document.getElementsByclassName('front');

x; // NodeList(4) [span.front, span.front, span.front, span.front]

for (var i = 0; i < x.length; i++) {
    x[i].innerHTML = 'TEXT' ;
}
</script>
```
